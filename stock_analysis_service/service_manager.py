#!/usr/bin/env python3
"""
HyperAsset Service Manager
ÏÑúÎπÑÏä§Îì§ÏùÑ ÏïàÏ†ÑÌïòÍ≤å ÏãúÏûë/Ï§ëÏßÄ/Î™®ÎãàÌÑ∞ÎßÅÌïòÎäî Îß§ÎãàÏ†Ä
"""

import os
import sys
import time
import json
import signal
import sqlite3
import logging
import subprocess
import threading
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('service_manager.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ServiceManager:
    def __init__(self):
        self.base_dir = Path(__file__).parent
        self.services_dir = self.base_dir / "services"
        self.processes: Dict[str, subprocess.Popen] = {}
        self.service_status_db = self.base_dir / "service_status.db"
        self.running = False
        
        # ÏÑúÎπÑÏä§ Ï†ïÏùò (Ìè¨Ìä∏ÏôÄ Ïã§Ìñâ ÌååÏùº)
        self.service_definitions = {
            "api_gateway": {
                "port": 8005,
                "script": "services/api_gateway/run.py",
                "description": "API Gateway Service",
                "dependencies": []
            },
            "user_service": {
                "port": 8006,
                "script": "services/user_service/user_service.py",
                "description": "User Management Service",
                "dependencies": []
            },
            "news_service": {
                "port": 8001,
                "script": "services/news_service/main.py",
                "description": "News Analysis Service",
                "dependencies": ["user_service"]
            },
            "disclosure_service": {
                "port": 8002,
                "script": "services/disclosure_service/disclosure_service.py",
                "description": "Disclosure Analysis Service",
                "dependencies": ["user_service"]
            },
            "report_service": {
                "port": 8004,
                "script": "services/report_service/report_service.py",
                "description": "Report Analysis Service",
                "dependencies": ["user_service"]
            },
            "chart_service": {
                "port": 8003,
                "script": "services/chart_service/chart_service.py",
                "description": "Chart Analysis Service",
                "dependencies": ["user_service"]
            },
            "flow_service": {
                "port": 8010,
                "script": "services/flow_analysis_service/flow_analysis_service.py",
                "description": "Flow Analysis Service",
                "dependencies": ["user_service"]
            },
            "orchestrator": {
                "port": 8000,
                "script": "services/orchestrator/main.py",
                "description": "Task Orchestrator Service",
                "dependencies": ["user_service"]
            }
        }
        
        self.init_status_db()
        
    def init_status_db(self):
        """ÏÑúÎπÑÏä§ ÏÉÅÌÉú Ï∂îÏ†Å DB Ï¥àÍ∏∞Ìôî"""
        try:
            conn = sqlite3.connect(self.service_status_db)
            conn.execute('''
                CREATE TABLE IF NOT EXISTS service_status (
                    service_name TEXT PRIMARY KEY,
                    status TEXT NOT NULL,
                    port INTEGER,
                    pid INTEGER,
                    started_at TEXT,
                    last_health_check TEXT,
                    error_count INTEGER DEFAULT 0,
                    description TEXT
                )
            ''')
            conn.commit()
            conn.close()
            logger.info("Service status DB initialized")
        except Exception as e:
            logger.error(f"Failed to init status DB: {e}")
    
    def update_service_status(self, service_name: str, status: str, pid: int = None):
        """ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            conn = sqlite3.connect(self.service_status_db)
            service_def = self.service_definitions.get(service_name, {})
            
            conn.execute('''
                INSERT OR REPLACE INTO service_status 
                (service_name, status, port, pid, started_at, last_health_check, description)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                service_name,
                status,
                service_def.get('port'),
                pid,
                datetime.now().isoformat() if status == 'running' else None,
                datetime.now().isoformat(),
                service_def.get('description', '')
            ))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Failed to update status for {service_name}: {e}")
    
    def is_port_available(self, port: int) -> bool:
        """Ìè¨Ìä∏ ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂Ä ÌôïÏù∏"""
        import socket
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex(('localhost', port))
                return result != 0
        except Exception:
            return True
    
    def start_service(self, service_name: str, user_id: str = None) -> bool:
        """Í∞úÎ≥Ñ ÏÑúÎπÑÏä§ ÏãúÏûë"""
        if service_name not in self.service_definitions:
            logger.error(f"Unknown service: {service_name}")
            return False
        
        service_def = self.service_definitions[service_name]
        
        # Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
        if service_name in self.processes and self.processes[service_name].poll() is None:
            logger.info(f"Service {service_name} is already running")
            return True
        
        # Ìè¨Ìä∏ ÏÇ¨Ïö© Í∞ÄÎä• Ïó¨Î∂Ä ÌôïÏù∏
        if not self.is_port_available(service_def['port']):
            logger.warning(f"Port {service_def['port']} is already in use for {service_name}")
            # Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Ï§ëÏù¥Ïñ¥ÎèÑ ÏÑúÎπÑÏä§Í∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏùº Ïàò ÏûàÏúºÎØÄÎ°ú ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨
            self.update_service_status(service_name, 'running')
            return True
        
        # ÏùòÏ°¥ÏÑ± ÌôïÏù∏
        for dep in service_def.get('dependencies', []):
            if not self.is_service_running(dep):
                logger.info(f"Starting dependency {dep} for {service_name}")
                if not self.start_service(dep, user_id):
                    logger.error(f"Failed to start dependency {dep}")
                    return False
                time.sleep(2)  # ÏùòÏ°¥ÏÑ± ÏÑúÎπÑÏä§ ÏãúÏûë ÎåÄÍ∏∞
        
        # Ïä§ÌÅ¨Î¶ΩÌä∏ Í≤ΩÎ°ú ÌôïÏù∏
        script_path = self.base_dir / service_def['script']
        if not script_path.exists():
            logger.error(f"Script not found: {script_path}")
            self.update_service_status(service_name, 'error')
            return False
        
        try:
            # ÏÑúÎπÑÏä§ ÏãúÏûë
            logger.info(f"Starting service: {service_name} on port {service_def['port']}")
            
            # Python ÌôòÍ≤Ω ÏÑ§Ï†ï
            env = os.environ.copy()
            env['PYTHONPATH'] = str(self.base_dir)
            
            # üî• ÏÇ¨Ïö©Ïûê ID ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ï†ÑÎã¨
            if user_id:
                env['HYPERASSET_USER_ID'] = user_id
                logger.info(f"Starting service {service_name} with user_id: {user_id}")
            
            # ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë
            process = subprocess.Popen(
                [sys.executable, str(script_path)],
                cwd=str(self.base_dir),
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            self.processes[service_name] = process
            self.update_service_status(service_name, 'starting', process.pid)
            
            # ÏÑúÎπÑÏä§ ÏãúÏûë ÌôïÏù∏ (ÏµúÎåÄ 10Ï¥à ÎåÄÍ∏∞)
            for i in range(10):
                if not self.is_port_available(service_def['port']):
                    self.update_service_status(service_name, 'running', process.pid)
                    logger.info(f"Service {service_name} started successfully on port {service_def['port']}")
                    return True
                time.sleep(1)
            
            # ÏãúÏûë Ïã§Ìå®
            logger.error(f"Service {service_name} failed to start within 10 seconds")
            self.update_service_status(service_name, 'failed')
            return False
            
        except Exception as e:
            logger.error(f"Failed to start service {service_name}: {e}")
            self.update_service_status(service_name, 'error')
            return False
    
    def stop_service(self, service_name: str) -> bool:
        """Í∞úÎ≥Ñ ÏÑúÎπÑÏä§ Ï§ëÏßÄ"""
        if service_name not in self.processes:
            logger.info(f"Service {service_name} is not running")
            return True
        
        try:
            process = self.processes[service_name]
            if process.poll() is None:  # ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä Ïã§Ìñâ Ï§ë
                logger.info(f"Stopping service: {service_name}")
                process.terminate()
                
                # Ï†ïÏÉÅ Ï¢ÖÎ£å ÎåÄÍ∏∞ (5Ï¥à)
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    logger.warning(f"Force killing service: {service_name}")
                    process.kill()
                    process.wait()
            
            del self.processes[service_name]
            self.update_service_status(service_name, 'stopped')
            logger.info(f"Service {service_name} stopped")
            return True
            
        except Exception as e:
            logger.error(f"Failed to stop service {service_name}: {e}")
            return False
    
    def is_service_running(self, service_name: str) -> bool:
        """ÏÑúÎπÑÏä§ Ïã§Ìñâ ÏÉÅÌÉú ÌôïÏù∏"""
        if service_name not in self.service_definitions:
            return False
        
        # ÌîÑÎ°úÏÑ∏Ïä§ ÌôïÏù∏
        if service_name in self.processes:
            if self.processes[service_name].poll() is None:
                return True
        
        # Ìè¨Ìä∏ ÌôïÏù∏
        port = self.service_definitions[service_name]['port']
        return not self.is_port_available(port)
    
    def start_core_services(self, user_id: str = None) -> bool:
        """ÌïµÏã¨ ÏÑúÎπÑÏä§Îì§ ÏãúÏûë (API Gateway, User Service)"""
        core_services = ["user_service", "api_gateway"]
        
        logger.info("Starting core services...")
        for service in core_services:
            if not self.start_service(service, user_id):
                logger.error(f"Failed to start core service: {service}")
                return False
            time.sleep(2)  # ÏÑúÎπÑÏä§ Í∞Ñ ÏãúÏûë Í∞ÑÍ≤©
        
        logger.info("Core services started successfully")
        return True
    
    def start_selected_services(self, service_list: List[str], user_id: str = None) -> bool:
        """ÏÑ†ÌÉùÎêú ÏÑúÎπÑÏä§Îì§ ÏãúÏûë"""
        logger.info(f"Starting selected services: {service_list} for user: {user_id}")
        
        # ÌïµÏã¨ ÏÑúÎπÑÏä§ Î®ºÏ†Ä ÏãúÏûë
        if not self.start_core_services(user_id):
            return False
        
        # ÏÑ†ÌÉùÎêú ÏÑúÎπÑÏä§Îì§ ÏãúÏûë
        for service in service_list:
            if service not in ["user_service", "api_gateway"]:  # ÌïµÏã¨ ÏÑúÎπÑÏä§Îäî Ïù¥ÎØ∏ ÏãúÏûëÎê®
                if not self.start_service(service, user_id):
                    logger.error(f"Failed to start service: {service}")
                    return False
                time.sleep(2)
        
        return True
    
    def get_service_status(self) -> Dict:
        """Î™®Îì† ÏÑúÎπÑÏä§ ÏÉÅÌÉú Ï°∞Ìöå"""
        try:
            conn = sqlite3.connect(self.service_status_db)
            cursor = conn.execute('SELECT * FROM service_status')
            
            status = {}
            for row in cursor.fetchall():
                service_name = row[0]
                status[service_name] = {
                    'status': row[1],
                    'port': row[2],
                    'pid': row[3],
                    'started_at': row[4],
                    'last_health_check': row[5],
                    'error_count': row[6],
                    'description': row[7],
                    'is_running': self.is_service_running(service_name)
                }
            
            conn.close()
            return status
            
        except Exception as e:
            logger.error(f"Failed to get service status: {e}")
            return {}
    
    def health_check(self):
        """ÏÑúÎπÑÏä§ ÏÉÅÌÉú Ï£ºÍ∏∞Ï†Å ÌôïÏù∏"""
        while self.running:
            try:
                for service_name in self.service_definitions:
                    is_running = self.is_service_running(service_name)
                    status = 'running' if is_running else 'stopped'
                    self.update_service_status(service_name, status)
                
                time.sleep(30)  # 30Ï¥àÎßàÎã§ ÌôïÏù∏
            except Exception as e:
                logger.error(f"Health check error: {e}")
                time.sleep(30)
    
    def signal_handler(self, signum, frame):
        """Ïã†Ìò∏ Ï≤òÎ¶¨ (Ctrl+C Îì±)"""
        logger.info("Received shutdown signal")
        self.shutdown()
    
    def shutdown(self):
        """Î™®Îì† ÏÑúÎπÑÏä§ Ï¢ÖÎ£å"""
        logger.info("Shutting down all services...")
        self.running = False
        
        for service_name in list(self.processes.keys()):
            self.stop_service(service_name)
        
        logger.info("Service manager shutdown complete")

# CLI Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
if __name__ == "__main__":
    manager = ServiceManager()
    
    # Ïã†Ìò∏ Ï≤òÎ¶¨Í∏∞ Îì±Î°ù
    signal.signal(signal.SIGINT, manager.signal_handler)
    signal.signal(signal.SIGTERM, manager.signal_handler)
    
    if len(sys.argv) < 2:
        print("Usage: python service_manager.py [start-core|start-all|stop|status|start-services service1,service2,...]")
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "start-core":
        manager.running = True
        if manager.start_core_services():
            print("Core services started successfully")
            # Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïä§Î†àÎìú ÏãúÏûë
            health_thread = threading.Thread(target=manager.health_check, daemon=True)
            health_thread.start()
            
            try:
                while manager.running:
                    time.sleep(1)
            except KeyboardInterrupt:
                pass
        else:
            print("Failed to start core services")
            sys.exit(1)
    
    elif command == "start-services" and len(sys.argv) > 2:
        services = sys.argv[2].split(',')
        manager.running = True
        if manager.start_selected_services(services):
            print(f"Selected services started: {services}")
            # Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïä§Î†àÎìú ÏãúÏûë
            health_thread = threading.Thread(target=manager.health_check, daemon=True)
            health_thread.start()
            
            try:
                while manager.running:
                    time.sleep(1)
            except KeyboardInterrupt:
                pass
        else:
            print("Failed to start selected services")
            sys.exit(1)
    
    elif command == "status":
        status = manager.get_service_status()
        print(json.dumps(status, indent=2))
    
    elif command == "stop":
        manager.shutdown()
        print("All services stopped")
    
    else:
        print("Invalid command")
        sys.exit(1) 