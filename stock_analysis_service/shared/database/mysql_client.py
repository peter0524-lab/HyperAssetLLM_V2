# type: ignore
"""
MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™®Îìà
Ï∞®Ìä∏ Ìå®ÌÑ¥ Îç∞Ïù¥ÌÑ∞ÏôÄ Í≥µÏãú Îç∞Ïù¥ÌÑ∞Î•º Í¥ÄÎ¶¨ÌïòÎäî MySQL Ïó∞Í≤∞ Î∞è ÏøºÎ¶¨ Í∏∞Îä• Ï†úÍ≥µ
"""

import pymysql
import pymysql.cursors
from pymysql import Error as PyMySQLError
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime, date
import json
from contextlib import contextmanager
import sys
from pathlib import Path

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Í≤ΩÎ°ú Ï∂îÍ∞Ä (stock_analysis_service)
project_root = Path(__file__).parent.parent.parent  # shared/database -> shared -> stock_analysis_service
sys.path.append(str(project_root))

# config Î™®Îìà ÏßÅÏ†ë import
config_path = project_root / "config"
sys.path.append(str(config_path))

from env_local import get_env_var, get_int_env_var, get_bool_env_var, load_env_vars
import asyncio
import threading
import queue
import time

# ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú Í∞ïÏ†ú Ïã§Ìñâ
load_env_vars()

# Î°úÍπÖ ÏÑ§Ï†ï
logger = logging.getLogger(__name__)


class MySQLConnectionPool:
    """PyMySQL Í∏∞Î∞ò Ïó∞Í≤∞ ÌíÄ Íµ¨ÌòÑ"""
    
    def __init__(self, pool_size: int = 10, **connection_params):
        self.pool_size = pool_size
        self.connection_params = connection_params
        self.pool = queue.Queue(maxsize=pool_size)
        self.lock = threading.Lock()
        self._create_pool()
    
    def _create_pool(self):
        """Ïó∞Í≤∞ ÌíÄ ÏÉùÏÑ±"""
        for _ in range(self.pool_size):
            try:
                connection = pymysql.connect(**self.connection_params)
                self.pool.put(connection)
            except Exception as e:
                logger.error(f"Ïó∞Í≤∞ ÌíÄ ÏÉùÏÑ± Ïã§Ìå®: {e}")
                raise
    
    def get_connection(self):
        """Ïó∞Í≤∞ ÌíÄÏóêÏÑú Ïó∞Í≤∞ Í∞ÄÏ†∏Ïò§Í∏∞"""
        try:
            connection = self.pool.get(timeout=10)  # üî• ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
            
            # üî• Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ Í∞ïÌôî
            if not self._is_connection_alive(connection):
                logger.warning("Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ïßê, ÏÉà Ïó∞Í≤∞ ÏÉùÏÑ±")
                connection.close()  # Í∏∞Ï°¥ Ïó∞Í≤∞ ÏôÑÏ†ÑÌûà Îã´Í∏∞
                connection = pymysql.connect(**self.connection_params)
            
            return connection
        except queue.Empty:
            # ÌíÄÏóê Ïó∞Í≤∞Ïù¥ ÏóÜÎã§Î©¥ ÏÉàÎ°ú ÏÉùÏÑ± (ÏûÑÏãú Ïó∞Í≤∞)
            logger.warning("Ïó∞Í≤∞ ÌíÄ Í≥†Í∞à, ÏûÑÏãú Ïó∞Í≤∞ ÏÉùÏÑ±")
            return pymysql.connect(**self.connection_params)
    
    def return_connection(self, connection):
        """Ïó∞Í≤∞ÏùÑ ÌíÄÏóê Î∞òÌôò"""
        if connection:
            try:
                if connection.open:
                    # Ïó∞Í≤∞Ïù¥ Ï†ïÏÉÅÏù¥Î©¥ ÌíÄÏóê Î∞òÌôò
                    self.pool.put_nowait(connection)
                else:
                    # Ïó∞Í≤∞Ïù¥ Îã´ÌòîÏúºÎ©¥ ÏôÑÏ†ÑÌûà Îã´Í∏∞
                    connection.close()
            except queue.Full:
                # ÌíÄÏù¥ Í∞ÄÎìù Ï∞®Î©¥ Ïó∞Í≤∞ Îã´Í∏∞
                logger.warning("Ïó∞Í≤∞ ÌíÄ Í∞ÄÎìùÏ∞∏, Ïó∞Í≤∞ Îã´Í∏∞")
                connection.close()
            except Exception as e:
                # ÏòàÏô∏ Î∞úÏÉùÏãú Ïó∞Í≤∞ Îã´Í∏∞
                logger.error(f"Ïó∞Í≤∞ Î∞òÌôò Ï§ë Ïò§Î•ò: {e}")
                try:
                    connection.close()
                except:
                    pass

    def _is_connection_alive(self, connection):
        """Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏"""
        try:
            if not connection.open:
                return False
            # pingÏúºÎ°ú Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
            connection.ping(reconnect=False)
            return True
        except Exception as e:
            logger.warning(f"Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®: {e}")
            return False


class MySQLClient:
    """MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÅ¥ÎûòÏä§"""

    def __init__(self, custom_config: Dict = None):
        """MySQL Ïó∞Í≤∞ ÌíÄ Ï¥àÍ∏∞Ìôî"""
        self.pool = None
        self._initialize_pool(custom_config)

    def _initialize_pool(self, custom_config: Dict = None) -> None:
        """MySQL Ïó∞Í≤∞ ÌíÄ ÏÉùÏÑ±"""
        try:
            env_config = {
                "user": get_env_var("DATABASE_USER", "root"),
                "password": get_env_var("DATABASE_PASSWORD", ""),
                "host": get_env_var("DATABASE_HOST", "127.0.0.1"),
                "port": get_int_env_var("DATABASE_PORT", 3306),
                "database": get_env_var("DATABASE_NAME", "backendTest"),
                "charset": "utf8mb4",
                "autocommit": True,
                "cursorclass": pymysql.cursors.DictCursor,
                # üî• ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï ÏµúÏ†ÅÌôî (Îçî Í∏¥ ÌÉÄÏûÑÏïÑÏõÉ)
                "connect_timeout": 60,  # Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ 60Ï¥à
                "read_timeout": 60,     # ÏùΩÍ∏∞ ÌÉÄÏûÑÏïÑÏõÉ 60Ï¥à  
                "write_timeout": 60,    # Ïì∞Í∏∞ ÌÉÄÏûÑÏïÑÏõÉ 60Ï¥à
                "ssl_disabled": True,   # AWS RDS SSL ÎπÑÌôúÏÑ±Ìôî
                # üî• Ïó∞Í≤∞ Ïú†ÏßÄ ÏÑ§Ï†ï Ï∂îÍ∞Ä
                "init_command": "SET SESSION wait_timeout=28800",  # 8ÏãúÍ∞Ñ
                "sql_mode": "STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO",
                # üî• Ïû¨Ïó∞Í≤∞ ÏÑ§Ï†ï
                "ping_interval": 300,   # 5Î∂ÑÎßàÎã§ ping
            }
            
            # custom_configÍ∞Ä Ï†ÑÎã¨ÎêòÎ©¥ env_configÏùÑ ÎçÆÏñ¥Ïì∞Í∏∞
            if custom_config:
                env_config.update(custom_config)
            config = env_config

            # üî• Ïó∞Í≤∞ ÌíÄ ÌÅ¨Í∏∞ ÏÑ§Ï†ï ÏµúÏ†ÅÌôî (Îçî ÎßéÏùÄ Ïó∞Í≤∞ ÌóàÏö©)
            pool_size = min(10, max(5, get_int_env_var("DATABASE_CONNECTION_LIMIT", 5)))
            
            # Ïó∞Í≤∞ ÌíÄÏóêÏÑú ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî ÏÑ§Ï†ï Ï†úÍ±∞
            pool_config = {k: v for k, v in config.items() if k not in ['pool_name', 'pool_size', 'pool_reset_session', 'ping_interval']}
            
            self.pool = MySQLConnectionPool(pool_size=pool_size, **pool_config)
            logger.info(
                f"MySQL Ïó∞Í≤∞ ÌíÄ ÏÉùÏÑ± ÏôÑÎ£å: {config['host']}:{config['port']}/{config['database']}"
            )

        except Exception as e:
            logger.error(f"MySQL Ïó∞Í≤∞ ÌíÄ ÏÉùÏÑ± Ïã§Ìå®: {e}")
            raise

    @contextmanager
    def get_connection(self):
        """Ïó∞Í≤∞ ÌíÄÏóêÏÑú Ïó∞Í≤∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä)"""
        connection = None
        try:
            connection = self.pool.get_connection()
            yield connection
        except Exception as e:
            logger.error(f"MySQL Ïó∞Í≤∞ Ïò§Î•ò: {e}")
            if connection:
                connection.rollback()
            raise
        finally:
            if connection:
                self.pool.return_connection(connection)

    def execute_query(
        self, query: str, params: Optional[tuple] = None, fetch: bool = True
    ) -> Optional[List[Dict]]:
        """ÏøºÎ¶¨ Ïã§Ìñâ Î∞è Í≤∞Í≥º Î∞òÌôò"""
        try:
            if not self.pool:
                return None
            
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)

                if fetch:
                    result = cursor.fetchall()
                    cursor.close()
                    return result
                else:
                    conn.commit()
                    affected_rows = cursor.rowcount
                    cursor.close()
                    return [{"affected_rows": affected_rows}]

        except Exception as e:
            logger.error(f"ÏøºÎ¶¨ Ïã§Ìñâ Ïò§Î•ò: {e}")
            logger.error(f"ÏøºÎ¶¨: {query}")
            logger.error(f"ÌååÎùºÎØ∏ÌÑ∞: {params}")
            raise

    def execute_many(self, query: str, params_list: List[tuple]) -> Dict:
        """Ïó¨Îü¨ Ìñâ ÏùºÍ¥Ñ ÏÇΩÏûÖ/ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            if not self.pool:
                return {"affected_rows": 0}
            
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.executemany(query, params_list)
                conn.commit()
                affected_rows = cursor.rowcount
                cursor.close()
                return {"affected_rows": affected_rows}

        except Exception as e:
            logger.error(f"ÏùºÍ¥Ñ ÏøºÎ¶¨ Ïã§Ìñâ Ïò§Î•ò: {e}")
            return {"affected_rows": 0}

    # === ÎπÑÎèôÍ∏∞ ÎûòÌçº Î©îÏÑúÎìú ===
    async def execute_query_async(
        self, query: str, params: tuple = None, fetch: bool = True, max_retries: int = 3
    ) -> Optional[List[Dict]]:
        """ÎπÑÎèôÍ∏∞ ÏøºÎ¶¨ Ïã§Ìñâ (ThreadPoolExecutor ÎûòÌçº) - Ïû¨ÏãúÎèÑ Î°úÏßÅ Ìè¨Ìï®"""
        loop = asyncio.get_event_loop()
        
        for attempt in range(max_retries):
            try:
                return await loop.run_in_executor(
                    None, self.execute_query, query, params, fetch
                )
            except Exception as e:
                logger.warning(f"ÏøºÎ¶¨ Ïã§Ìñâ Ïã§Ìå® (ÏãúÎèÑ {attempt + 1}/{max_retries}): {e}")
                if attempt == max_retries - 1:
                    logger.error(f"ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º, ÏøºÎ¶¨ Ïã§Ìñâ Ïã§Ìå®: {query}")
                    raise
                # Ïû¨ÏãúÎèÑ Ï†Ñ Ïû†Ïãú ÎåÄÍ∏∞
                await asyncio.sleep(1 * (attempt + 1))  # ÏßÄÏàò Î∞±Ïò§ÌîÑ
        
        return None

    async def execute_many_async(self, query: str, params_list: List[tuple]) -> Dict:
        """ÎπÑÎèôÍ∏∞ executemany Ïã§Ìñâ (ThreadPoolExecutor ÎûòÌçº)"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.execute_many, query, params_list)

    def fetch_one(self, query: str, params: Optional[tuple] = None) -> Optional[Dict]:
        """Îã®Ïùº Ìñâ Ï°∞Ìöå"""
        try:
            if not self.pool:
                return None
            
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)
                result = cursor.fetchone()
                cursor.close()
                return result
        except Exception as e:
            logger.error(f"fetch_one Ïã§Ìñâ Ïò§Î•ò: {e}")
            return None

    def fetch_all(self, query: str, params: Optional[tuple] = None) -> List[Dict]:
        """Î™®Îì† Ìñâ Ï°∞Ìöå"""
        try:
            if not self.pool:
                return []
            
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)
                result = cursor.fetchall()
                cursor.close()
                return result if result else []
        except Exception as e:
            logger.error(f"fetch_all Ïã§Ìñâ Ïò§Î•ò: {e}")
            return []

    async def fetch_one_async(self, query: str, params: tuple = None) -> Optional[Dict]:
        """ÎπÑÎèôÍ∏∞ Îã®Ïùº Î†àÏΩîÎìú Ï°∞Ìöå (ThreadPoolExecutor ÎûòÌçº)"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.fetch_one, query, params)

    async def fetch_all_async(self, query: str, params: Optional[tuple] = None) -> List[Dict]:
        """ÎπÑÎèôÍ∏∞ Î™®Îì† Ìñâ Ï°∞Ìöå"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self.fetch_all, query, params)

    async def close(self) -> None:
        """Ïó∞Í≤∞ ÌíÄ Ï†ïÎ¶¨"""
        try:
            if self.pool:
                logger.info("MySQL Ïó∞Í≤∞ ÌíÄ Ï†ïÎ¶¨ Ï§ë...")
                # Î™®Îì† Ïó∞Í≤∞ Îã´Í∏∞
                while not self.pool.pool.empty():
                    conn = self.pool.pool.get_nowait()
                    if conn and conn.open:
                        conn.close()
                logger.info("MySQL Ïó∞Í≤∞ ÌíÄ Ï†ïÎ¶¨ ÏôÑÎ£å")
        except Exception as e:
            logger.error(f"MySQL Ïó∞Í≤∞ ÌíÄ Ï†ïÎ¶¨ Ïã§Ìå®: {e}")
            raise

    def get_current_price_data(self, stock_code: str) -> Optional[Dict]:
        """ÌòÑÏû¨ Ï£ºÍ∞Ä Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        query = """
        SELECT stock_code, current_price, change_rate, volume, trade_date
        FROM stock_prices 
        WHERE stock_code = %s 
        ORDER BY trade_date DESC, trade_time DESC 
        LIMIT 1
        """
        return self.fetch_one(query, (stock_code,))

    def run_service(self, service_name: str) -> Dict:
        """ÏÑúÎπÑÏä§ Ïã§Ìñâ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        query = """
        UPDATE service_status 
        SET status = 'running', last_updated = NOW()
        WHERE service_name = %s
        """
        return self.execute_query(query, (service_name,), fetch=False)

    def get_chart_patterns(
        self,
        stock_code: str,
        condition_id: str = None,
        start_date: date = None,
        end_date: date = None,
    ) -> List[Dict]:
        """Ï∞®Ìä∏ Ìå®ÌÑ¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        query = """
        SELECT 
            id, stock_code, stock_name, condition_id, condition_name,
            trigger_date, trigger_time, price, volume, 
            pattern_data, similar_volume, created_at
        FROM chart_patterns 
        WHERE stock_code = %s
        """
        params = [stock_code]

        if condition_id:
            query += " AND condition_id = %s"
            params.append(condition_id)

        if start_date:
            query += " AND trigger_date >= %s"
            params.append(start_date)

        if end_date:
            query += " AND trigger_date <= %s"
            params.append(end_date)

        query += " ORDER BY trigger_date DESC, trigger_time DESC"

        return self.execute_query(query, tuple(params))

    def save_chart_pattern(self, pattern_data: Dict) -> int:
        """Ï∞®Ìä∏ Ìå®ÌÑ¥ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•"""
        query = """
        INSERT INTO chart_patterns (
            stock_code, stock_name, condition_id, condition_name,
            trigger_date, trigger_time, price, volume, 
            pattern_data, similar_volume, created_at
        ) VALUES (
            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
        )
        """

        params = (
            pattern_data["stock_code"],
            pattern_data["stock_name"],
            pattern_data["condition_id"],
            pattern_data["condition_name"],
            pattern_data["trigger_date"],
            pattern_data["trigger_time"],
            pattern_data["price"],
            pattern_data["volume"],
            json.dumps(pattern_data.get("pattern_data", {}), ensure_ascii=False),
            pattern_data.get("similar_volume", 0),
            datetime.now(),
        )

        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)
                conn.commit()
                pattern_id = cursor.lastrowid
                cursor.close()
                logger.info(f"Ï∞®Ìä∏ Ìå®ÌÑ¥ Ï†ÄÏû• ÏôÑÎ£å: ID={pattern_id}")
                return pattern_id

        except Exception as e:
            logger.error(f"Ï∞®Ìä∏ Ìå®ÌÑ¥ Ï†ÄÏû• Ïò§Î•ò: {e}")
            raise

    def get_disclosures(
        self, stock_code: str, start_date: date = None, end_date: date = None
    ) -> List[Dict]:
        """Í≥µÏãú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        query = """
        SELECT 
            id, stock_code, stock_name, disclosure_type, title, 
            summary, impact_score, similar_case, publication_date,
            created_at, updated_at
        FROM disclosures 
        WHERE stock_code = %s
        """
        params = [stock_code]

        if start_date:
            query += " AND publication_date >= %s"
            params.append(start_date)

        if end_date:
            query += " AND publication_date <= %s"
            params.append(end_date)

        query += " ORDER BY publication_date DESC"

        return self.execute_query(query, tuple(params))

    def save_disclosure(self, disclosure_data: Dict) -> int:
        """Í≥µÏãú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•"""
        query = """
        INSERT INTO disclosures (
            stock_code, stock_name, disclosure_type, title, 
            summary, impact_score, similar_case, publication_date,
            created_at, updated_at
        ) VALUES (
            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
        )
        """

        params = (
            disclosure_data["stock_code"],
            disclosure_data["stock_name"],
            disclosure_data["disclosure_type"],
            disclosure_data["title"],
            disclosure_data["summary"],
            disclosure_data.get("impact_score", 0.0),
            disclosure_data.get("similar_case", ""),
            disclosure_data["publication_date"],
            datetime.now(),
            datetime.now(),
        )

        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute(query, params)
                conn.commit()
                disclosure_id = cursor.lastrowid
                cursor.close()
                logger.info(f"Í≥µÏãú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å: ID={disclosure_id}")
                return disclosure_id

        except Exception as e:
            logger.error(f"Í≥µÏãú Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïò§Î•ò: {e}")
            raise

    def get_similar_chart_pattern(
        self, stock_code: str, condition_id: str, current_volume: int
    ) -> Optional[Dict]:
        """Ïú†ÏÇ¨Ìïú Ï∞®Ìä∏ Ìå®ÌÑ¥ Í≤ÄÏÉâ (Í∞ÄÏû• Ïú†ÏÇ¨Ìïú Í±∞ÎûòÎüâ + ÏµúÍ∑º ÏºÄÏù¥Ïä§)"""
        query = """
        SELECT 
            id, stock_code, stock_name, condition_id, condition_name,
            trigger_date, trigger_time, price, volume, 
            pattern_data, similar_volume, created_at,
            ABS(volume - %s) as volume_diff
        FROM chart_patterns 
        WHERE stock_code = %s AND condition_id = %s
        ORDER BY volume_diff ASC, trigger_date DESC
        LIMIT 1
        """

        params = (current_volume, stock_code, condition_id)
        result = self.execute_query(query, params)

        return result[0] if result else None

    def get_system_metrics(self) -> Dict:
        """ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ Ï°∞Ìöå"""
        queries = {
            "chart_patterns_count": "SELECT COUNT(*) as count FROM chart_patterns",
            "disclosures_count": "SELECT COUNT(*) as count FROM disclosures",
            "recent_chart_patterns": """
                SELECT COUNT(*) as count FROM chart_patterns 
                WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
            """,
            "recent_disclosures": """
                SELECT COUNT(*) as count FROM disclosures 
                WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
            """,
        }

        metrics = {}
        for key, query in queries.items():
            try:
                result = self.execute_query(query)
                metrics[key] = result[0]["count"] if result else 0
            except Exception as e:
                logger.error(f"Î©îÌä∏Î¶≠ Ï°∞Ìöå Ïò§Î•ò ({key}): {e}")
                metrics[key] = 0

        return metrics

    def health_check(self) -> Dict:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏"""
        try:
            start_time = time.time()
            
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT VERSION()")
                version_result = cursor.fetchone()
                version = version_result.get('VERSION()', 'Unknown') if version_result else 'Unknown'
                
                cursor.execute("SELECT 1")
                result = cursor.fetchone()
                cursor.close()

                connection_time = time.time() - start_time

                return {
                    "status": "healthy",
                    "version": version,
                    "connection_time": f"{connection_time:.3f}s",
                    "connection_pool_size": self.pool.pool_size,
                    "timestamp": datetime.now().isoformat(),
                }

        except Exception as e:
            logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®: {e}")
            return {
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.now().isoformat(),
            }


def init_database() -> None:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî - ÌÖåÏù¥Î∏î ÏÉùÏÑ±"""
    client = MySQLClient()

    # Ï∞®Ìä∏ Ìå®ÌÑ¥ ÌÖåÏù¥Î∏î
    chart_patterns_table = """
    CREATE TABLE IF NOT EXISTS chart_patterns (
        id INT AUTO_INCREMENT PRIMARY KEY,
        stock_code VARCHAR(10) NOT NULL,
        stock_name VARCHAR(100) NOT NULL,
        condition_id VARCHAR(50) NOT NULL,
        condition_name VARCHAR(100) NOT NULL,
        trigger_date DATE NOT NULL,
        trigger_time TIME NOT NULL,
        price DECIMAL(10, 2) NOT NULL,
        volume BIGINT NOT NULL,
        pattern_data JSON,
        similar_volume BIGINT DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        INDEX idx_stock_code (stock_code),
        INDEX idx_condition_id (condition_id),
        INDEX idx_trigger_date (trigger_date),
        INDEX idx_volume (volume),
        INDEX idx_created_at (created_at)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
    """

    # Í≥µÏãú Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î
    disclosures_table = """
    CREATE TABLE IF NOT EXISTS disclosures (
        id INT AUTO_INCREMENT PRIMARY KEY,
        stock_code VARCHAR(10) NOT NULL,
        stock_name VARCHAR(100) NOT NULL,
        disclosure_type VARCHAR(50) NOT NULL,
        title VARCHAR(500) NOT NULL,
        summary TEXT,
        impact_score DECIMAL(3, 2) DEFAULT 0.00,
        similar_case TEXT,
        publication_date DATE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_stock_code (stock_code),
        INDEX idx_disclosure_type (disclosure_type),
        INDEX idx_publication_date (publication_date),
        INDEX idx_impact_score (impact_score),
        INDEX idx_created_at (created_at)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
    """

    try:
        # ÌÖåÏù¥Î∏î ÏÉùÏÑ±
        client.execute_query(chart_patterns_table, fetch=False)
        client.execute_query(disclosures_table, fetch=False)

        logger.info("Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        print("‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    except Exception as e:
        logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
        print(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
        raise


# Ï†ÑÏó≠ MySQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ (ÏßÄÏó∞ Ï¥àÍ∏∞Ìôî)
mysql_client = None


def get_mysql_client() -> MySQLClient:
    """MySQL ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò (ÏßÄÏó∞ Ï¥àÍ∏∞Ìôî)"""
    global mysql_client
    if mysql_client is None:
        mysql_client = MySQLClient()
    return mysql_client
