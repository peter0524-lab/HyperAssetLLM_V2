# 🚀 신규 서비스 개발 가이드

## 📋 개요

이 문서는 주식 분석 시스템에 새로 추가된 3개 서비스의 기능 개발을 위한 완전한 가이드입니다.

**🎯 개발 대상 서비스:**

1. **Issue Scheduler Service** (포트 8007) - 기업 이슈 일정 관리
2. **Business Report Service** (포트 8008) - 사업보고서 AI 요약
3. **Analysis Service** (포트 8009) - 주가 원인 분석 (기능 보완)

## 🏗️ 시스템 아키텍처 이해

### **현재 구현 상태**

- ✅ **API 엔드포인트**: 모든 엔드포인트 구조 완성
- ✅ **서비스 통합**: API Gateway, 시스템 시작 스크립트 연동 완료
- ✅ **기본 구조**: FastAPI, 공통 모듈 import, 로깅, CORS 설정 완료
- ⏳ **실제 기능**: TODO 주석으로 구현 가이드 제공 (개발 필요)

### **공통 기술 스택**

```python
# 필수 라이브러리
- FastAPI: REST API 서버
- uvicorn: ASGI 서버
- aiohttp: 비동기 HTTP 클라이언트
- MySQL: 메인 데이터베이스
- ChromaDB: 벡터 데이터베이스
- LLM Manager: 다중 LLM 지원 (HyperCLOVA, ChatGPT 등)
```

### **공통 모듈 활용**

```python
# 이미 import되어 있는 공통 모듈들
from shared.database.mysql_client import MySQLManager
from shared.llm.llm_manager import LLMManager
from shared.user_config.user_config_manager import UserConfigManager
from shared.apis.dart_api import DartAPI
from shared.apis.telegram_api import TelegramBotClient
```

---

## 🗓️ Issue Scheduler Service 개발 가이드

### **📍 서비스 위치**

```
stock_analysis_service/services/issue_scheduler/
├── __init__.py ✅
└── issue_scheduler.py ✅ (API만 구현됨)
```

### **🎯 기능 명세**

#### **1️⃣ 핵심 기능**

**📅 이슈 캘린더 크롤링**

```python
# TODO 구현 위치: get_upcoming_issues()
async def get_upcoming_issues(self, stock_codes: List[str], days_ahead: int = 30):
    """
    구현해야 할 것:
    1. FnGuide 캘린더 크롤링 (https://comp.fnguide.com/SVO2/ASP/SVD_Corp.asp?pGB=1&gicode=A005930)
    2. 증권사 캘린더 API 연동
    3. 이슈 유형별 분류:
       - 유상증자/무상증자
       - 실적발표 (분기/연간)
       - 주주총회
       - 배당 (배당락일, 배당지급일)
       - 공모주 상장
       - 기타 중요 일정
    """
```

**🤖 이슈 중요도 분석**

```python
# TODO 구현 위치: analyze_issue_importance()
async def analyze_issue_importance(self, issue: Dict[str, Any]):
    """
    구현해야 할 것:
    1. LLM 프롬프트 설계:
       - "다음 기업 이슈가 주가에 미칠 영향도를 0-1점으로 평가하세요"
       - 이슈 유형, 기업 규모, 과거 사례 등 고려
    2. 중요도 점수 기반 알림 필터링 (0.7 이상만 알림)
    3. 과거 유사 이슈 사례 검색 (VectorDB 활용)
    """
```

**🔔 알림 시스템**

```python
# TODO 구현 위치: send_issue_alert()
async def send_issue_alert(self, user_id: str, issue: Dict[str, Any]):
    """
    구현해야 할 것:
    1. 알림 시점:
       - D-3: 사전 알림 (실적발표 등)
       - D-1: 하루 전 알림
       - D-day: 당일 아침 알림
    2. 알림 내용 템플릿:
       "📅 [삼성전자] 내일(1/30) 4분기 실적발표 예정
        💡 지난 분기 대비 예상 실적: +15%
        📊 과거 실적발표 후 평균 주가 변동: +3.2%"
    3. 다중 채널 지원: 텔레그램, 이메일, 푸시
    """
```

#### **2️⃣ 데이터베이스 스키마**

```sql
-- 이슈 캘린더 테이블
CREATE TABLE issue_calendar (
    id INT AUTO_INCREMENT PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    company_name VARCHAR(200) NOT NULL,
    event_type VARCHAR(50) NOT NULL, -- 'earnings', 'dividend', 'rights', 'meeting'
    event_date DATE NOT NULL,
    event_title VARCHAR(500) NOT NULL,
    description TEXT,
    importance_score DECIMAL(3,2), -- 0.00-1.00
    source VARCHAR(100), -- 'fnguide', 'securities_firm', 'dart'
    source_url TEXT,
    is_notified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_stock_event_date (stock_code, event_date),
    INDEX idx_event_type (event_type),
    INDEX idx_importance_score (importance_score)
);

-- 사용자 알림 설정 테이블
CREATE TABLE user_issue_alert_settings (
    user_id VARCHAR(50) NOT NULL,
    stock_code VARCHAR(10) NOT NULL,
    event_types JSON, -- ['earnings', 'dividend'] 등
    alert_days_before JSON, -- [1, 3, 7] 등
    min_importance_score DECIMAL(3,2) DEFAULT 0.7,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (user_id, stock_code)
);
```

#### **3️⃣ 크롤링 구현 예시**

```python
import asyncio
from selenium import webdriver
from selenium.webdriver.common.by import By
from bs4 import BeautifulSoup
import requests

async def crawl_fnguide_calendar(self, stock_codes: List[str]) -> List[Dict]:
    """FnGuide 이슈 캘린더 크롤링"""

    # Selenium 설정
    options = webdriver.ChromeOptions()
    options.add_argument('--headless')
    options.add_argument('--no-sandbox')

    driver = webdriver.Chrome(options=options)
    results = []

    try:
        for stock_code in stock_codes:
            url = f"https://comp.fnguide.com/SVO2/ASP/SVD_Corp.asp?pGB=1&gicode=A{stock_code}"
            driver.get(url)

            # 캘린더 섹션 파싱
            calendar_section = driver.find_element(By.CLASS_NAME, "calendar-section")

            # 이슈 추출 로직 구현
            # ...

    finally:
        driver.quit()

    return results
```

#### **4️⃣ API 엔드포인트 완성**

| 엔드포인트                          | 구현 상태 | TODO                     |
| ----------------------------------- | --------- | ------------------------ |
| `GET /issues/upcoming`              | 🔴 미구현 | FnGuide 크롤링 + DB 조회 |
| `POST /issues/analyze`              | 🔴 미구현 | LLM 중요도 분석          |
| `POST /alerts/send`                 | 🔴 미구현 | 텔레그램/이메일 발송     |
| `GET /issues/calendar/{stock_code}` | 🔴 미구현 | 종목별 캘린더 조회       |

---

## 📊 Business Report Service 개발 가이드

### **📍 서비스 위치**

```
stock_analysis_service/services/business_report_service/
├── __init__.py ✅
└── business_report_service.py ✅ (API만 구현됨)
```

### **🎯 기능 명세**

#### **1️⃣ 핵심 기능**

**📄 사업보고서 수집**

```python
# TODO 구현 위치: get_business_report()
async def get_business_report(self, stock_code: str, report_type: str = "annual"):
    """
    구현해야 할 것:
    1. DART API 연동:
       - 정기보고서 목록 조회: /api/list.json
       - 사업보고서 원문: /api/document.json
    2. 보고서 유형별 처리:
       - annual: 사업보고서 (연간)
       - quarterly: 분기보고서
       - semi: 반기보고서
    3. 텍스트 추출 및 전처리
    """

    # DART API 호출 예시
    dart_api = self.dart_api

    # 1. 보고서 목록 조회
    reports = await dart_api.get_report_list(
        corp_code=stock_code,
        bsns_year="2024",
        reprt_code="11011"  # 사업보고서
    )

    # 2. 최신 보고서 다운로드
    latest_report = reports[0]
    document = await dart_api.get_document(
        rcept_no=latest_report['rcept_no']
    )

    return document
```

**🤖 투자 관점 특화 요약**

```python
# TODO 구현 위치: summarize_report()
async def summarize_report(self, stock_code: str, report_data: Dict, user_id: str = None):
    """
    구현해야 할 것:
    1. LLM 프롬프트 설계 (기획서 참조):

    당신은 주식 애널리스트입니다. 다음 텍스트는 사업보고서입니다.
    "주가에 영향을 줄 수 있는 정보만" 요약해 주세요.

    요약 항목:
    1. 📦 주요 고객사 및 계약
       - (고객사명)과의 수주 계약 체결
       - 납품처, 매출 비중 등

    2. 🚀 신규 사업 및 투자
       - 신사업(예: AI/2차전지 등)
       - M&A, 공장 증설, 해외 진출 등

    3. ⚠️ 리스크 요인
       - 원가 상승, 규제, 소송, 기술 실패 등

    4. 🔮 향후 계획 및 실적 전망
       - 회사의 사업 전략 요약
       - 향후 매출 예상, IR 가이던스
    """

    # LLM 요약 실행
    llm_client = await self.llm_manager.get_client_for_user(user_id)

    summary = await llm_client.generate_response(
        prompt=prompt,
        context=report_data['text']
    )

    return summary
```

**📋 PDF 리포트 생성**

```python
# TODO 구현 위치: generate_report_pdf()
async def generate_report_pdf(self, stock_code: str, summary_data: Dict):
    """
    구현해야 할 것:
    1. reportlab 라이브러리 사용
    2. 템플릿 디자인:
       - 회사 로고/기본 정보
       - 4개 섹션별 정리
       - 차트/그래프 삽입
    3. 파일 저장 및 다운로드 링크 제공
    """

    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4

    # PDF 생성 로직
    pdf_path = f"reports/{stock_code}_business_report_{datetime.now().strftime('%Y%m%d')}.pdf"

    c = canvas.Canvas(pdf_path, pagesize=A4)

    # 헤더
    c.drawString(100, 750, f"{summary_data['company_name']} 사업보고서 요약")

    # 각 섹션별 내용 추가
    # ...

    c.save()
    return pdf_path
```

#### **2️⃣ 데이터베이스 스키마**

```sql
-- 사업보고서 요약 테이블
CREATE TABLE business_report_summaries (
    id INT AUTO_INCREMENT PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    company_name VARCHAR(200) NOT NULL,
    report_type VARCHAR(20) NOT NULL, -- 'annual', 'quarterly', 'semi'
    report_year YEAR NOT NULL,
    report_period VARCHAR(10), -- 'Q1', 'Q2', 'Q3', 'Q4' or NULL

    -- 요약 내용 (JSON 형태)
    major_clients JSON,
    new_business JSON,
    risk_factors JSON,
    future_plans JSON,

    -- 메타 정보
    dart_rcept_no VARCHAR(20),
    summary_generated_at TIMESTAMP,
    pdf_file_path VARCHAR(500),
    requested_by_user_id VARCHAR(50),

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_stock_year (stock_code, report_year),
    INDEX idx_report_type (report_type),
    INDEX idx_user_requests (requested_by_user_id)
);

-- 사용자 사업보고서 요청 히스토리
CREATE TABLE user_report_requests (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    stock_code VARCHAR(10) NOT NULL,
    report_type VARCHAR(20) NOT NULL,
    request_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    summary_id INT,

    FOREIGN KEY (summary_id) REFERENCES business_report_summaries(id)
);
```

#### **3️⃣ DART API 연동**

```python
# DART API 클라이언트 확장
class DartAPIExtended:

    async def get_report_list(self, corp_code: str, bsns_year: str, reprt_code: str):
        """보고서 목록 조회"""
        url = "https://opendart.fss.or.kr/api/list.json"
        params = {
            'crtfc_key': self.api_key,
            'corp_code': corp_code,
            'bgn_de': f"{bsns_year}0101",
            'end_de': f"{bsns_year}1231",
            'reprt_code': reprt_code
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as response:
                return await response.json()

    async def get_document(self, rcept_no: str):
        """보고서 원문 다운로드"""
        url = "https://opendart.fss.or.kr/api/document.json"
        params = {
            'crtfc_key': self.api_key,
            'rcept_no': rcept_no
        }

        # ZIP 파일 다운로드 및 텍스트 추출 로직
        # ...
```

#### **4️⃣ API 엔드포인트 완성**

| 엔드포인트                             | 구현 상태 | TODO                    |
| -------------------------------------- | --------- | ----------------------- |
| `POST /reports/summarize/{stock_code}` | 🔴 미구현 | DART API + LLM 요약     |
| `GET /reports/{stock_code}`            | 🔴 미구현 | 원본 보고서 조회        |
| `POST /reports/pdf/{stock_code}`       | 🔴 미구현 | PDF 생성 및 저장        |
| `GET /reports/history/{user_id}`       | 🔴 미구현 | 사용자 요청 히스토리    |
| `GET /reports/available/{stock_code}`  | 🔴 미구현 | 사용 가능한 보고서 목록 |

---

## 📈 Analysis Service 개발 가이드

### **📍 서비스 위치**

```
stock_analysis_service/services/analysis_service/
├── __init__.py ✅
└── analysis_service.py ✅ (기본 기능 구현됨, 보완 필요)
```

### **🎯 현재 상태 및 보완 사항**

#### **1️⃣ 이미 구현된 기능 ✅**

- 주가 급등락 감지 (10% 이상 + 1000만주 이상)
- KIS API 연동한 실시간 주가 조회
- MySQL 데이터베이스 연동
- 기본 API 엔드포인트들

#### **2️⃣ 추가 구현 필요한 기능 🔴**

**📊 차트 클릭 시 원인 분석 UI**

```python
# 새로운 엔드포인트 추가 필요
@app.post("/explain/click-analysis")
async def explain_price_movement(
    stock_code: str,
    target_date: str,
    click_position: Dict[str, float]  # {x: timestamp, y: price}
):
    """
    구현해야 할 것:
    1. 클릭한 날짜의 주가 데이터 분석
    2. 해당 날짜 전후 뉴스/공시/차트 패턴 검색
    3. 과거 유사 사례 매칭 (VectorDB)
    4. LLM을 통한 종합 원인 분석
    5. 프론트엔드용 응답 포맷팅
    """

    # 1. 해당 날짜 주가 데이터 조회
    price_data = await get_price_data(stock_code, target_date)

    # 2. 뉴스/공시 데이터 검색
    news_data = await search_news_by_date(stock_code, target_date)
    disclosure_data = await search_disclosure_by_date(stock_code, target_date)

    # 3. 차트 패턴 분석
    chart_pattern = await analyze_chart_pattern(stock_code, target_date)

    # 4. 과거 유사 사례 검색
    similar_cases = await search_similar_cases(price_data, news_data)

    # 5. LLM 종합 분석
    analysis_result = await llm_analyze_price_movement({
        'price_data': price_data,
        'news': news_data,
        'disclosure': disclosure_data,
        'chart_pattern': chart_pattern,
        'similar_cases': similar_cases
    })

    return {
        'status': 'success',
        'stock_code': stock_code,
        'target_date': target_date,
        'analysis': analysis_result,
        'evidence': {
            'news': news_data,
            'disclosure': disclosure_data,
            'chart_pattern': chart_pattern,
            'similar_cases': similar_cases
        }
    }
```

**🧠 설명가능한 AI (XAI) 알고리즘**

```python
# 옵션: GAAN 알고리즘 구현
class ExplainableAI:
    """설명가능한 AI 주가 분석"""

    def __init__(self):
        # GAAN (Graph Attention Adversarial Network) 또는
        # LIME (Local Interpretable Model-agnostic Explanations) 구현
        pass

    async def explain_price_movement(self, features: Dict) -> Dict:
        """
        구현해야 할 것:
        1. 주가 변동 요인별 중요도 점수 계산
        2. 시각화용 어텐션 맵 생성
        3. 요인별 기여도 퍼센테이지 계산
        """

        # 요인별 중요도 분석
        importance_scores = {
            'news_sentiment': 0.35,      # 뉴스 감정 점수
            'disclosure_impact': 0.25,   # 공시 영향도
            'technical_indicators': 0.20, # 기술적 지표
            'market_sentiment': 0.15,    # 시장 전체 분위기
            'trading_volume': 0.05       # 거래량 패턴
        }

        return importance_scores
```

**🔍 고도화된 유사 사례 검색**

```python
async def search_similar_cases_advanced(self, current_case: Dict) -> List[Dict]:
    """
    구현해야 할 것:
    1. 다차원 유사도 계산:
       - 주가 변동 패턴 유사도 (코사인 유사도)
       - 뉴스 내용 유사도 (벡터 임베딩)
       - 거래량 패턴 유사도
       - 시장 상황 유사도
    2. 가중치 기반 종합 유사도 점수
    3. 상위 N개 유사 사례 반환
    """

    # 벡터 검색
    vector_results = await self.vector_db.similarity_search(
        collection_name="price_analysis_vectors",
        query_vector=current_case['embedding'],
        top_k=10
    )

    # 추가 필터링 및 랭킹
    filtered_results = []
    for result in vector_results:
        # 시간적 거리, 변동률 유사도 등 추가 고려
        similarity_score = calculate_multi_dimensional_similarity(
            current_case, result
        )

        if similarity_score > 0.7:  # 임계값
            filtered_results.append({
                'case': result,
                'similarity': similarity_score
            })

    return sorted(filtered_results, key=lambda x: x['similarity'], reverse=True)[:5]
```

#### **3️⃣ 프론트엔드 연동**

```typescript
// 프론트엔드에서 차트 클릭 이벤트 처리
interface ChartClickEvent {
  stock_code: string;
  timestamp: number;
  price: number;
  volume: number;
}

const handleChartClick = async (event: ChartClickEvent) => {
  try {
    const response = await fetch("/api/analysis/explain/click-analysis", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        stock_code: event.stock_code,
        target_date: new Date(event.timestamp).toISOString().split("T")[0],
        click_position: {
          x: event.timestamp,
          y: event.price,
        },
      }),
    });

    const analysis = await response.json();

    // 분석 결과를 모달이나 사이드패널에 표시
    showAnalysisModal(analysis);
  } catch (error) {
    console.error("분석 요청 실패:", error);
  }
};
```

---

## 🛠️ 개발 환경 설정

### **1️⃣ 필수 패키지 설치**

```bash
# 추가 패키지 설치
pip install selenium webdriver-manager beautifulsoup4
pip install reportlab PyPDF2 pdfplumber
pip install scikit-learn pandas numpy
pip install python-multipart python-jose[cryptography]
```

### **2️⃣ 환경 변수 설정**

```bash
# .env 파일에 추가
DART_API_KEY=your_dart_api_key
FNGUIDE_API_KEY=your_fnguide_api_key  # 필요시
CHROME_DRIVER_PATH=/path/to/chromedriver
```

### **3️⃣ 데이터베이스 스키마 적용**

```bash
# MySQL에 새 테이블 생성
python -c "
from services.issue_scheduler.issue_scheduler import IssueSchedulerService
from services.business_report_service.business_report_service import BusinessReportService
import asyncio

# 스키마 생성 실행
asyncio.run(create_new_schemas())
"
```

---

## 🧪 테스트 방법

### **1️⃣ 단위 테스트**

```python
# test_issue_scheduler.py
import pytest
from services.issue_scheduler.issue_scheduler import IssueSchedulerService

@pytest.mark.asyncio
async def test_get_upcoming_issues():
    service = IssueSchedulerService()
    result = await service.get_upcoming_issues(['005930'], 30)

    assert result['status'] == 'success'
    assert isinstance(result['issues'], list)

# test_business_report.py
import pytest
from services.business_report_service.business_report_service import BusinessReportService

@pytest.mark.asyncio
async def test_summarize_report():
    service = BusinessReportService()
    result = await service.summarize_report('005930', {'text': 'test report'})

    assert result['status'] == 'success'
    assert 'summary' in result
```

### **2️⃣ 통합 테스트**

```python
# test_integration.py
async def test_full_workflow():
    """전체 워크플로우 테스트"""

    # 1. Issue Scheduler
    issues = await issue_scheduler.get_upcoming_issues(['005930'])
    assert len(issues['issues']) > 0

    # 2. Business Report
    summary = await business_report.summarize_report('005930', 'annual')
    assert summary['status'] == 'success'

    # 3. Analysis Service
    analysis = await analysis_service.analyze_price_movement('005930', '2024-01-15')
    assert analysis['status'] == 'success'
```

### **3️⃣ API 테스트**

```bash
# Issue Scheduler 테스트
curl -X GET "http://localhost:8007/issues/upcoming?stock_codes=005930&days_ahead=30"

# Business Report 테스트
curl -X POST "http://localhost:8008/reports/summarize/005930" \
  -H "Content-Type: application/json" \
  -d '{"user_id": "test_user", "report_type": "annual"}'

# Analysis Service 테스트
curl -X POST "http://localhost:8009/explain/click-analysis" \
  -H "Content-Type: application/json" \
  -d '{"stock_code": "005930", "target_date": "2024-01-15", "click_position": {"x": 1705276800, "y": 75000}}'
```

---

## 📚 참고 자료

### **1️⃣ 외부 API 문서**

- [DART API 가이드](https://opendart.fss.or.kr/guide/main.do)
- [KIS API 문서](https://apiportal.koreainvestment.com/)
- [FnGuide 데이터 구조](https://comp.fnguide.com/)

### **2️⃣ 기존 코드 참조**

- `services/news_service/main.py` - 크롤링 및 LLM 연동 패턴
- `services/disclosure_service/disclosure_service.py` - DART API 사용법
- `shared/llm/llm_manager.py` - LLM 활용 방법

### **3️⃣ 데이터베이스 참조**

- `database/complete_schema.sql` - 기존 스키마 구조
- `shared/database/mysql_client.py` - DB 연동 방법

---

## ✅ 개발 체크리스트

### **Issue Scheduler Service**

- [ ] FnGuide 크롤링 구현
- [ ] 이슈 중요도 LLM 분석
- [ ] 알림 시스템 구현
- [ ] 데이터베이스 스키마 생성
- [ ] 단위 테스트 작성
- [ ] API 문서 작성

### **Business Report Service**

- [ ] DART API 연동 완성
- [ ] 투자 관점 요약 LLM 구현
- [ ] PDF 생성 기능
- [ ] 사용자 히스토리 관리
- [ ] 단위 테스트 작성
- [ ] API 문서 작성

### **Analysis Service**

- [ ] 차트 클릭 분석 API 추가
- [ ] XAI 알고리즘 구현 (선택사항)
- [ ] 유사 사례 검색 고도화
- [ ] 프론트엔드 연동 인터페이스
- [ ] 단위 테스트 추가
- [ ] 기존 기능 테스트

---

## 🚀 배포 가이드

### **1️⃣ 개발 완료 후 확인사항**

```bash
# 1. 모든 서비스 시작 확인
python start_all_services.py

# 2. 헬스체크 확인
python check_services_health.py

# 3. 통합 테스트 실행
python test_frontend_data_flow.py
```

### **2️⃣ 프로덕션 배포**

- 환경변수 확인 (`DART_API_KEY` 등)
- 데이터베이스 백업
- 로그 모니터링 설정
- 에러 알림 설정

---

## 💬 문의사항

개발 중 문의사항이 있으시면:

1. 기존 코드 구조 참조 (`services/` 폴더의 다른 서비스들)
2. 공통 모듈 활용 (`shared/` 폴더)
3. API Gateway 연동 확인
4. 로그 파일 확인

**🎯 성공적인 개발을 위해 이 가이드를 단계별로 따라 진행하시기 바랍니다!**
